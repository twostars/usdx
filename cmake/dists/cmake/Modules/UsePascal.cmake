# Copyright (c) 2009 Tobias Gunkel <tobigun@at@users.sourceforge.net>
#
# Copying and distribution of this file, with or without
# modification, are permitted in any medium without royalty provided
# the copyright notice and this notice are preserved.

# - Creates a virtual Pascal package.
#   Do not mix this up with Delphi (dpk), FPC or Lazarus (lpk) packages.
#   A package specified by this command does not define a dll or similar.
#   It is just a compilation of units, includes and object-dirs
#   (mostly used for header files).
#   This information will be appended to a module generated by
#   add_pascal_module() if a package is specified with the PACKAGE
#   option.
#   You can pass additional compiler flags with
#     <COMPILER>_FLAGS (for all module types) and
#     <COMPILER>_LIBRARY_FLAGS (for libraries only)
#   where <COMPILER> must be either FPC or DELPHI.
# PASCAL_ADD_PACKAGE(
#   <name>
#   [UNITS    file1 [...]]
#   [INCLUDES file1 [...]]
#   [OBJECT_DIRS dir1 [...]]
#   [<COMPILER>_FLAGS ...]
#   [<COMPILER>_LIBRARY_FLAGS]
# )
#
# - Builds a Pascal module.
#   The module can be a program, library or unit. The type is either autodetected
#   (by the file header) or can be set by the appropriate flag.
#   The output name for executables and libraries (exe, dll, so) will be the
#   name of the target (or the one given by OUTPUT_NAME). It will be located in 
#   the current binary dir by default (or in the directory given by OUTPUT_DIR).
#   If main_source is a unit the name of the generated object file (mostly a .o/.ppu pair)
#   will match the units name and located in an extra directory (like i386-linux) in the
#   current binary dir.
#   It is recommended to pass all unit (pas/pp) files and include (inc) files required
#   by the module with the UNITS/INCLUDES flags. Although dependencies are normally 
#   already defined in the project file (.lpr/.dpr/...) FPC is not able to reliably track
#   changes in dependencies as it does not search for source-files besides the directory
#   of the project file. When calling FPC directly the user has to pass all paths to source
#   files with the -Fu flag, otherwise FPC will not recompile changed source-files.
#   If you pass all source files (wildcards as dir/*.pas are allowed) with UNITS/INCLUDES
#   pascal_add_module does this for you. In addition the filenames are appended to auto-generated
#   project files for e.g. lazarus.
#   The UNITS/INCLUDES files are also used as dependencies for triggering a rebuild. If REBUILD_ALL
#   is not specified FPC tries to perform a minimal rebuild (only files that changed). If inline
#   functions are used in your project's sources FPC might not be able to perform a minimum rebuild
#   and compiles lots of unchanged units too.
#   (See http://www.mail-archive.com/fpc-devel@lists.freepascal.org/msg11914.html)
#   If for some reason a minimal rebuild fails, specify
#   REBUILD_ALL to recompile all units used by your project.
#   Units/includes used by packages specified by the PACKAGES option do not have to be specified
#   again with UNITS/INCLUDES. Package sources are not appended to auto-generated project files
#   for lazarus.
#   You can pass additional compiler flags with <COMPILER>_FLAGS where <COMPILER> 
#   must be one of FPC or DELPHI.
#   Sets target properties:
#     - PASCAL_TYPE:            module type (one of PROGRAM/LIBRARY/UNIT)
#     - PASCAL_LOCATION:        full path of output file (equivalent to LOCATION)
# PASCAL_ADD_MODULE(
#   <name>
#   [PROGRAM | LIBRARY | UNIT]
#   <main_source>
#   [OUTPUT_NAME name]
#   [OUTPUT_DIR dir]
#   [<COMPILER>_FLAGS ...]
#   [DEPENDS depend [...]]
#   [UNITS    file1 [...]]
#   [INCLUDES file1 [...]]
#   [OBJECT_DIRS dir1 [...]]
#   [PACKAGES pkg1 [...]]
#   [EXCLUDE_FROM_ALL]
#   [REBUILD_ALL]
# )
#
# - Macro for handling Pascal configuration files
#   Works as configure_file(InputFile OutputFile) but in addition
#   it replaces occurences of {$CMAKEDEFINE(VAR) XYZ} with
#     {$DEFINE XYZ} if the value of VAR is true  
#     {$UNDEF XYZ} if the value of VAR is false  
# PASCAL_CONFIGURE_FILE(InputFile OutputFile)
#

include(MacroParseArguments)
include(LazarusGenerator)

option(GENERATE_LAZARUS_PROJECTS "Generate lazarus project files (.lpi) for every Pascal target" OFF)

function(PASCAL_ADD_PACKAGE name)
  # setup a list of property names to copy from the arguments
  set(prop_list)
  list(APPEND prop_list OBJECT_DIRS)
  foreach(comp FPC DELPHI)
    list(APPEND prop_list ${comp}_FLAGS ${comp}_LIBRARY_FLAGS)
  endforeach(comp)

  # parse arguments
  set(ARG)
  parse_arguments(ARG 
    "UNITS;INCLUDES;${prop_list}"
    ""
    ${ARGN}
  )

  # transform file paths to absolute paths
  set(unit_abs_list)
  foreach(unit ${ARG_UNITS})
    get_filename_component(unit_abs ${unit} ABSOLUTE)
    list(APPEND unit_abs_list ${unit_abs})
  endforeach(unit)
  set(inc_abs_list)
  foreach(inc ${ARG_INCLUDES})
    get_filename_component(inc_abs ${inc} ABSOLUTE)
    list(APPEND inc_abs_list ${inc_abs})
  endforeach(inc)

  # store info in global properties
  set_property(GLOBAL PROPERTY PASCAL_PKG_${name}_EXISTS TRUE)
  set_property(GLOBAL PROPERTY PASCAL_PKG_${name}_UNITS    "${unit_abs_list}")
  set_property(GLOBAL PROPERTY PASCAL_PKG_${name}_INCLUDES "${inc_abs_list}")
  foreach(prop ${prop_list})
    set_property(GLOBAL PROPERTY PASCAL_PKG_${name}_${prop} "${ARG_${prop}}")
  endforeach(prop)
endfunction(PASCAL_ADD_PACKAGE)

macro(PASCAL_ADD_MODULE)
  set(ARG)
  parse_arguments(ARG
    "OUTPUT_NAME;OUTPUT_DIR;DEPENDS;UNITS;INCLUDES;OBJECT_DIRS;PACKAGES;FPC_FLAGS;DELPHI_FLAGS"
    "EXCLUDE_FROM_ALL;REBUILD_ALL"
    ${ARGN}
  )

  # check parameter count
  list(LENGTH ARG_DEFAULT_ARGS defargs_cnt)
  if(defargs_cnt LESS 2)
    message(FATAL_ERROR "ADD_PASCAL_MODULE called with incorrect number of arguments")
  endif(defargs_cnt LESS 2)

  set(arg_index 0)

  # get target parameter
  list(GET ARG_DEFAULT_ARGS ${arg_index} target)
  math(EXPR arg_index "${arg_index}+1")

  # determine file type
  list(GET ARG_DEFAULT_ARGS ${arg_index} type)
  set(type_list "PROGRAM;LIBRARY;UNIT")
  list(FIND type_list ${type} type_index)
  if(type_index EQUAL -1)
    set(type AUTO)
  else(type_index EQUAL -1)
    math(EXPR arg_index "${arg_index}+1")
  endif(type_index EQUAL -1)

  # get source parameter
  if(arg_index EQUAL 2)
    if(defargs_cnt LESS 3)
      message(FATAL_ERROR "ADD_PASCAL_MODULE called with incorrect number of arguments")
    endif(defargs_cnt LESS 3)
  endif(arg_index EQUAL 2)
  list(GET ARG_DEFAULT_ARGS ${arg_index} source)

  # autodetect type
  if(type STREQUAL AUTO)
    file(STRINGS ${CMAKE_CURRENT_SOURCE_DIR}/${source} source_lines)
    string(TOUPPER "${source_lines}" source_lines)
    foreach(line ${source_lines})
      string(REGEX MATCH "^[ \t]*PROGRAM[ \t]+[A-Za-z0-9_]+[ \t]*;" line_match "${line}")
      if(line_match) 
        set(type PROGRAM)
        break()
      endif(line_match) 

      string(REGEX MATCH "^[ \t]*LIBRARY[ \t]+[A-Za-z0-9_]+[ \t]*;" line_match "${line}")
      if(line_match) 
        set(type LIBRARY)
        break()
      endif(line_match) 

      string(REGEX MATCH "^[ \t]*UNIT[ \t]+[A-Za-z0-9_]+[ \t]*;" line_match "${line}")
      if(line_match) 
        set(type UNIT)
        break()
      endif(line_match) 
    endforeach(line)

    if(type STREQUAL AUTO)
      message(FATAL_ERROR "Autodetection of Pascal source-type failed")
    endif(type STREQUAL AUTO)
  endif(type STREQUAL AUTO)

  # init list of additional "make clean" files
  set(extra_clean_files "")

  # set output directory
  if(ARG_OUTPUT_DIR)
    set(output_dir ${ARG_OUTPUT_DIR})
  else()
    set(output_dir ${CMAKE_CURRENT_BINARY_DIR})
  endif()

  # set compiled units (ppu/obj) output directory
  set(unit_out_dir ${CMAKE_CURRENT_BINARY_DIR}/${FPC_TARGET})
  list(APPEND extra_clean_files ${unit_out_dir})

  # set output-file basename
  if(ARG_OUTPUT_NAME)
    set(output_name ${ARG_OUTPUT_NAME})
  else()
    set(output_name ${target})
  endif()

  # create output filename
  if(type STREQUAL PROGRAM)
    set(output "${output_dir}/${output_name}${CMAKE_EXECUTABLE_SUFFIX}")
    list(APPEND extra_clean_files ${output})
  endif(type STREQUAL PROGRAM)
  if(type STREQUAL LIBRARY)
    set(output "${output_dir}/${PASCAL_LIBRARY_PREFIX}${output_name}${PASCAL_LIBRARY_SUFFIX}")
    list(APPEND extra_clean_files ${output})
  endif(type STREQUAL LIBRARY)
  if(type STREQUAL UNIT)
    get_filename_component(source_name ${source} NAME_WE)
    set(output "${unit_out_dir}/${source_name}.o")
    # no need to add output to clean files
  endif(type STREQUAL UNIT)

  # set additional "make clean" files (Note: set_directory_properties() has no APPEND option)
  set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES "${extra_clean_files}")

  # set working dir
  set(work_dir ${CMAKE_CURRENT_SOURCE_DIR})

  # assemble pascal compiler flags
  set(pflags ${PASCAL_FLAGS})
  if(type STREQUAL LIBRARY)
    list(APPEND pflags ${PASCAL_LIBRARY_FLAGS})
  endif(type STREQUAL LIBRARY)
  if(CMAKE_BUILD_TYPE STREQUAL Release)
    list(APPEND pflags ${PASCAL_FLAGS_RELEASE})
  elseif(CMAKE_BUILD_TYPE STREQUAL Debug)
    list(APPEND pflags ${PASCAL_FLAGS_DEBUG})
  elseif(CMAKE_BUILD_TYPE STREQUAL RelWithDebInfo)
    list(APPEND pflags ${PASCAL_FLAGS_RELWITHDEBINFO})
  elseif(CMAKE_BUILD_TYPE STREQUAL MinSizeRelDebug)
    list(APPEND pflags ${PASCAL_FLAGS_MINSIZEREL})
  endif()

  # set target specific flags
  list(APPEND pflags ${ARG_${PASCAL_COMPILER_TYPE}_FLAGS})

  # init unit/include/object dir list
  set(unit_dirs "")
  set(inc_dirs "")
  set(obj_dirs "")

  # add packages
  foreach(pkg ${ARG_PACKAGES})
    # check existence
    set(pkg_exists)
    get_property(pkg_exists GLOBAL PROPERTY PASCAL_PKG_${pkg}_EXISTS)
    if(NOT pkg_exists)
      message(FATAL_ERROR "Unknown pascal package \"${pkg}\". See pascal_add_package().")
    endif(NOT pkg_exists)

    # append package units
    set(pkg_units)
    get_property(pkg_units GLOBAL PROPERTY PASCAL_PKG_${pkg}_UNITS)
    list(APPEND units ${pkg_units})

    # append package includes
    set(pkg_incs)
    get_property(pkg_incs GLOBAL PROPERTY PASCAL_PKG_${pkg}_INCLUDES)
    list(APPEND incs ${pkg_incs})

    # append package object dirs
    set(pkg_obj_dirs)
    get_property(pkg_obj_dirs GLOBAL PROPERTY PASCAL_PKG_${pkg}_OBJECT_DIRS)
    list(APPEND obj_dirs ${pkg_obj_dirs})

    # append package flags
    set(pkg_flags)
    get_property(pkg_flags GLOBAL PROPERTY PASCAL_PKG_${pkg}_${PASCAL_COMPILER_TYPE}_FLAGS)
    list(APPEND pflags ${pkg_flags})

    # append package library flags if appropriate
    if(type STREQUAL LIBRARY)
      set(pkg_lib_flags)
      get_property(pkg_lib_flags GLOBAL PROPERTY PASCAL_PKG_${pkg}_${PASCAL_COMPILER_TYPE}_LIBRARY_FLAGS)
      list(APPEND pflags ${pkg_lib_flags})
    endif(type STREQUAL LIBRARY)
  endforeach(pkg ${ARG_PACKAGES})

  # add unit/include/object dirs passed as macro parameter
  list(APPEND units ${ARG_UNITS})
  # extract unit directories
  foreach(unit ${units})
    get_filename_component(unit_dir ${unit} PATH)    
    list(APPEND unit_dirs ${unit_dir})
  endforeach(unit)
  list(REMOVE_DUPLICATES unit_dirs)

  list(APPEND incs ${ARG_INCLUDES})
  # extract inc directories
  foreach(inc ${incs})
    get_filename_component(inc_dir ${inc} PATH)    
    list(APPEND inc_dirs ${inc_dir})
  endforeach(inc)
  list(REMOVE_DUPLICATES inc_dirs)

  list(APPEND obj_dirs ${ARG_OBJECT_DIRS})
  list(REMOVE_DUPLICATES obj_dirs)

  # process unit/include/object directories
  set(dir_flag_list)
  foreach(flag_dir ${unit_dirs})
    get_filename_component(flag_abs_dir ${flag_dir} ABSOLUTE)
    file(RELATIVE_PATH flag_rel_dir ${work_dir} ${flag_abs_dir})
    list(APPEND dir_flag_list -Fu${flag_rel_dir})
  endforeach(flag_dir)
  foreach(flag_dir ${inc_dirs})
    get_filename_component(flag_abs_dir ${flag_dir} ABSOLUTE)
    file(RELATIVE_PATH flag_rel_dir ${work_dir} ${flag_abs_dir})
    list(APPEND dir_flag_list -Fi${flag_rel_dir})
  endforeach(flag_dir)
  foreach(flag_dir ${obj_dirs})
    get_filename_component(flag_abs_dir ${flag_dir} ABSOLUTE)
    file(RELATIVE_PATH flag_rel_dir ${work_dir} ${flag_abs_dir})
    list(APPEND dir_flag_list -Fo${flag_rel_dir})
  endforeach(flag_dir)

  # add *.pas/*.pp of each unit-dir and *.inc of each inc-dir
  # to the depends list
  set(depends)
  list(APPEND depends ${units} ${incs})

  # check if we are to add the target to ALL
  set(custom_target_all "ALL")
  if(ARG_EXCLUDE_FROM_ALL)
    set(custom_target_all)
  endif(ARG_EXCLUDE_FROM_ALL)

  # check if even unchanged units should be rebuild
  if(ARG_REBUILD_ALL)
    # Note that the -B (build all modules) option does not work if not all
    # unit-directories the project uses are passed with the -Fu flag.
    # Sources in directories not given with -Fu (even if listed in the dpr/lpr file)
    # are never recompiled.
    # As a safer method clean the unit-output directory instead but keep
    # the -B flag for lazarus project files as it does not hurt.
    set(unit_out_clean COMMAND ${CMAKE_COMMAND} -E remove_directory ${unit_out_dir})
    list(APPEND pflags -B)
  endif(ARG_REBUILD_ALL)

  # lower-case project type (just for user info)
  string(TOLOWER ${type} proj_type_lowcase)

  # timestamp filename
  set(target_timestamp ${CMAKE_CURRENT_BINARY_DIR}/${target}_timestamp)

  # output filename
  get_filename_component(output_file ${output} NAME)

  # add command
  add_custom_command(
    OUTPUT ${target_timestamp}
    # delete and create units dir (needed for proper update)
    ${unit_out_clean}
    COMMAND ${CMAKE_COMMAND} -E make_directory ${unit_out_dir}
    # build
    COMMAND ${PASCAL_COMPILER} 
            ${pflags} 
            ${dir_flag_list}
            -FU${unit_out_dir}
            -o${output}
            ${source}
    # update timestamp
    COMMAND ${CMAKE_COMMAND} -E touch ${target_timestamp}
    WORKING_DIRECTORY ${work_dir}
    MAIN_DEPENDENCY ${source}
    COMMENT "Building Pascal ${proj_type_lowcase} ${output_file}"
    DEPENDS ${ARG_DEPENDS} ${depends}
  )

  # add target
  add_custom_target(${target}
    ${custom_target_all}
    COMMENT "Checking dependencies of target ${target}"
    DEPENDS ${target_timestamp}
  )

  # we cannot set the TYPE target property so specify our own property
  set_target_properties(${target} PROPERTIES PASCAL_TYPE ${type})

  # similar to the target property LOCATION we specify the output file
  # of the target
  set_target_properties(${target} PROPERTIES PASCAL_LOCATION ${output})

  if(GENERATE_LAZARUS_PROJECTS)
    generate_lazarus_project(
      ${source}
      ${output}
      ${unit_out_dir}
      "${ARG_UNITS}"
      "${unit_dirs}"
      "${ARG_INCLUDES}"
      "${inc_dirs}"
      "${obj_dirs}"
      "${pflags}"
    )
  endif(GENERATE_LAZARUS_PROJECTS)
endmacro(PASCAL_ADD_MODULE)

macro(PASCAL_CONFIGURE_FILE)
  file(READ ${ARGV0} config_file)
  string(REGEX MATCHALL "{\\$CMAKEDEFINE\\([^\\)]+\\)" pasdefine_list "${config_file}")
  foreach(pasdefine ${pasdefine_list})
    string(REGEX REPLACE "{\\$CMAKEDEFINE\\(([^\\)]+)\\)" "\\1" pasdefine_var ${pasdefine})
    if (${pasdefine_var})
      string(REPLACE ${pasdefine} "{$DEFINE" config_file "${config_file}")
    else (${pasdefine_var})
      string(REPLACE ${pasdefine} "{$UNDEF" config_file "${config_file}")
    endif (${pasdefine_var})	
  endforeach(pasdefine)
  string(CONFIGURE "${config_file}" config_file)
  file(WRITE ${ARGV1} "${config_file}")
endmacro(PASCAL_CONFIGURE_FILE)
